# $Id$
#
# >>Title::     Language Definitions Module
#
# >>Copyright::
# Copyright (c) 1992-1996, Ian Clatworthy (ianc@mincom.com).
# You may distribute under the terms specified in the LICENSE file.
#
# >>History::
# -----------------------------------------------------------------------
# Date      Who     Change
# 29-Feb-96 ianc    SDF 2.000
# -----------------------------------------------------------------------
#
# >>Purpose::
# {{MOD:langdefs}} defines language definitions used in [[SDF]]
# documents.
#
# >>Description::
#
# >>Limitations::
#

!block langdefs
# For SDF, treat the built-in macros as keywords.
# We also need to put all the keywords on one line to get around
# parsing problems related to lines beginning with !.
SDF|sdf|sdm|sde|sdn:\
    :cb=#:ce=$:sb=":se=\e":lb=':\
    :le=\e':\
    :kw=!build_title !block !endblock !include !execute !import !use !inherit !on !off !if !elsif !elseif !else !endif !init !define !default !undef !restrict !export !class !macro !endmacro !message !line !script !insert !getdoc !getcode !getusage !perlapi

# From the Perl FAQ
PERL|perl|Perl|pl|pm:\
    :pb=^\d?(sub|package)\d\p\d:\
    :bb={:be=}:cb=#:ce=$:sb=":se=\e":lb=':\
    :le=\e':tl:\
    :id=_:\
    :kw=\
    if for foreach unless until while continue else elsif \
    do eval require \
    die exit \
    defined delete reset \
    goto last redo next dump \
    local undef return  \
    write format  \
    sub package

# From Kent Sandvik (sandvik@sgi.com)
java:\
        :pb=^\d?*?\d?\p\d?\(\a?\)(\d|{):bb={:be=}:cb=/*:ce=*/:ab=//:\
        :ae=$:sb=":se=\e":lb=':\
        :le=\e':tl:\
        :kw=asm auto break case char const continue default do double else enum\
        extern float for goto if int long register return short signed\
        sizeof static struct switch typedef union unsigned void volatile while\
        class delete friend inline new operator overload private\
        protected public template this virtual import boolean extends\
        implements final

# From Prachin Ranavat (prachin@mincom.com)
C|c:\
    :pb=^\d?*?\d?\p\d?\(\a?\)(\d|{):bb={:be=}:cb=/*:ce=*/:sb=":se=\e":lb=':\
    :le=\e':tl:\
    :kw=asm auto break case char continue default do double else enum\
    extern float for fortran goto if int long register return short\
    sizeof static struct switch typedef union unsigned void while #define\
    #else #endif #if #ifdef #ifndef #include #undef # define endif\
    ifdef ifndef include undef defined:
C++|c++|cpp|hpp|CC|cc|h:\
    :pb=^\d?*?\d?\p\d?\(\a?\)(\d|{):bb={:be=}:cb=/*:ce=*/:ab=//:\
    :ae=$:sb=":se=\e":lb=':\
    :le=\e':tl:\
    :kw=asm auto break case char continue default do double else enum\
    extern float for fortran goto if int long register return short\
    sizeof static struct switch typedef union unsigned while void #define\
    #else #endif #if #ifdef #ifndef #include #undef # define endif\
    ifdef ifndef include undef defined\
    catch class const delete friend inline new operator overload private\
    protected public throw try virtual:
IDL|idl:\
	:pb=^\d?*?\d?\p\d?\(\a?\)(\d|{):bb={:be=}:cb=/*:ce=*/:ab=//:\
	:ae=$:sb=":se=\e":lb=':\
	:le=\e':tl:\
	:kw=any attribute boolean case char const context default double\
	enum exception float in inout interface long module octet oneway\
	out raises readonly sequence short string struct switch typedef\
	unsigned union void FALSE Object TRUE #define #undef #include #if\
	#ifdef #ifndef #elif #else #endif #defined #error #pragma:
fortran|FORTRAN|f77|fc|f|for:\
    :pb=(function|subroutine|program)\d\p\d?\(\a?\):\
    :bb=(function|subroutine|program)\d\p\d?\(\a?\):be=^\dend:\
    :cb=^c:\
    :ce=$:\
    :sb=':\
    :se=':\
    :oc:\
    :kw=call common complex continue dimension do double else elseif\
    end endif equivalence format function\
    goto if include integer \
    parameter precision real return stop subroutine:
Delphi|Pascal|pas|int:\
    :pb=(^\d?procedure|function|program\d\p\d|\(|;|\:)|(=\d?record\d):\
    :bb=\dcase|begin\d:be=\dend|forward\d|;:\
    :cb={:ce=}:\
    :ab=\(*:ae=*\):\
    :sb=':se=':\
    :kw=absolute abstract and array as asm assembler at begin case cdcel\
    class const constructor default destructor div do downto dynamic else\
    end except export exports external far file finally for forward\
    function goto if implementation in index inherited initialization\
    inline interface interrupt is label library messages mod name near\
    nil nodefault not object of on or override packed private procedure\
    program property protected public published raise read record repeat\
    resident set shl shr stored string then to try type unit until uses\
    var virtual while with write xor
SH|sh:\
    :pb=(;|^)\d?\p\(\)(\d|{):\
    :ab=\$#:ae=(\d?|\a?):\
    :bb={:be=}:cb=#:ce=$:sb=":se=\e":lb=':\
    :le=\e':tl:\
    :kw=break case cd continue do done \
    elif else esac eval exec exit export \
    fi for if in then while until \
    read readonly set shift test trap umask wait:
CSH|csh:\
    :cb=#:ce=$:sb=":se=\e":lb=':\
    :ab=\$\a?#:ae=(\d?|\a?):\
    :le=\e':tl:\
    :kw=alias alloc break breaksw case cd chdir continue default\
    echo else end endif endsw exec exit foreach \
    glob goto history if logout nice nohup onintr repeat set\
    setenv shift source switch then time \
    while umask unalias unset wait while @ env \
    argv child home ignoreeof noclobber noglob \
    nomatch path prompt shell status verbose :
#
# TJH added in a quick set of COBOL things ... why not!
#
COBOL|cobol:\
    :ab=*:ae=$:
    :kw=SECTION CALL PERFORM VARYING FROM BY UNTIL\
    IF END-IF ELSE NOT LESS AND OR EQUAL COMPUTE ADD SUBTRACT\
    MOVE TO EXIT SEARCH DIVISION AUTHOR GO TO GOTO\
    PIC COMP COMP-5 STRING PROGRAM-ID
MIMSCOBOL|mimscobol|PCOM|pcom|precom|PRECOM:\
    :ab=*:ae=$:
    :kw=SECTION CALL PERFORM VARYING FROM BY UNTIL\
    IF END-IF ELSE NOT LESS AND OR EQUAL COMPUTE ADD SUBTRACT\
    MOVE TO EXIT SEARCH DIVISION AUTHOR GO TO GOTO\
    PIC COMP COMP-5 STRING PROGRAM-ID\
    EXEC END-EXEC MACRO MEND
!endblock

